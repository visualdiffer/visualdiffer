fastlane_version "2.229.0"

default_platform(:mac)

require 'kramdown'
require 'time'
require 'tmpdir'

import "Sparkle"
import "Linter"

platform :mac do
  before_all do

    ENV["LC_ALL"] = "en_US.UTF-8"
    ENV["LANG"] = "en_US.UTF-8"
    ENV["PROJECT_ROOT"] = File.expand_path("..", __dir__)

    # derived variables
    ENV["APP_PATH"] = File.join(ENV["PROJECT_ROOT"], ENV['EXPORT_PATH'], "#{ENV['APP_NAME']}.app")
    ENV["APP_VERSION"] = get_version_number(xcodeproj: ENV["PROJECT_PATH"], target: ENV["TARGET"])
    ENV["ZIP_NAME"] = "#{ENV['APP_NAME']}-#{ENV["APP_VERSION"]}.zip"
    ENV["ZIP_PATH"] = File.join(ENV["PROJECT_ROOT"], ENV["EXPORT_PATH"], ENV['ZIP_NAME'])

    UI.message("üèóÔ∏è Environment loaded: #{ENV['FASTLANE_ENVIRONMENT'] || 'default'}")
  end

  desc "Create release, build project and create the zip file"
  lane :release do
    check_release_version
    lint_app
    format_app(
      check: true
    )
    build_archive_app
    verify_codesign

    notarize_app if ENV["NOTARIZE_ENABLED"] == "true"
    zip_app
    github if ENV["GITHUB_ENABLED"] == "true"
    sparkle if ENV["SPARKLE_ENABLED"] == "true"
    UI.success("üéâ Release completed")
  end

  private_lane :check_release_version do
    app_version = Gem::Version.new(ENV["APP_VERSION"])
    last_version = Gem::Version.new(last_git_tag.gsub(/^v/, ''))
    
    UI.user_error!("App version must be greater than the last tag. You must increase the version before creating a new release.") if app_version <= last_version
  end

  private_lane :build_archive_app do
    UI.header("üß± Build & Archive")
    clean_build_artifacts
    gym(
      project: ENV["PROJECT_PATH"],
      scheme: find_scheme,
      archive_path: ENV["ARCHIVE_PATH"],
      export_method: "developer-id",
      export_options: {
        signingStyle: "manual",
        signingCertificate: "Developer ID Application",
        teamID: ENV["TEAM_ID"]
      },
      output_directory: ENV["EXPORT_PATH"]
    )
  end

  private_lane :verify_codesign do
    UI.header("üîè Verify sign")
    result = sh("codesign --verify --deep --strict --verbose=2 '#{ENV["APP_PATH"]}'", log: true)
    if result.include?('satisfies its Designated Requirement')
      UI.success("‚úÖ Sign is valid")
    else
      UI.user_error!("Cosign output does not contain 'satisfies its Designated Requirement'")
    end
  end

  private_lane :zip_app do
    UI.header("üì¶ Build ZIP")
    sh("ditto -c -k --sequesterRsrc --keepParent #{ENV["APP_PATH"]} #{ENV["ZIP_PATH"]}")
    UI.message("‚úÖ ZIP created: #{ENV["ZIP_PATH"]}")
  end

  private_lane :notarize_app do
    UI.header("üßæ Notarization")

    key_filepath = File.expand_path(ENV['NOTARIZE_API_KEY_PATH'])

    api_key = app_store_connect_api_key(
      key_id: ENV['NOTARIZE_API_KEY_ID'],
      issuer_id: ENV['NOTARIZE_API_ISSUER_ID'],
      key_filepath: key_filepath
    )
    
    notarize(
      package: ENV["APP_PATH"],
      api_key: api_key,
      use_notarytool: true,
      try_early_stapling: true
    )
    UI.success("‚úÖ App notarized and stapled")
  end

  desc "Create and upload release to GitHub"
  lane :github do
    UI.header("üöÄ GitHub distribution")
    note_file_name = File.join(ENV["BUILD_PATH"], ENV["RELEASE_NOTE_PATH"], ENV["APP_VERSION"])
    notes_full_path = File.join(ENV["PROJECT_ROOT"], "#{note_file_name}.md")
    UI.user_error!("Unable to find #{note_file_name}") unless File.exist?(notes_full_path)
    notes = File.read(notes_full_path)

    result = set_github_release(
      repository_name: ENV["GITHUB_REPO"],
      api_token: ENV["GITHUB_API_TOKEN"],
      tag_name: "v#{ENV["APP_VERSION"]}",
      name: "#{ENV['APP_NAME']} v#{ENV["APP_VERSION"]}",
      description: notes,
      is_prerelease: (ENV["APP_VERSION"] =~ /(alpha|beta|rc)/i).to_i > 0,
      upload_assets: [ENV["ZIP_PATH"]]
    )

    # GitHub creates the remote tag, so ensures local tags are up to date with remote ones
    sh('git fetch --tags')

    UI.success("‚úÖ GitHub release completed")
  end

  def find_scheme
    if ENV["SPARKLE_ENABLED"] == "true"
      scheme = ENV["SPARKLE_SCHEME"] 

      UI.user_error!("Scheme for sparkle not defined") if scheme.nil? || scheme.empty?
      return scheme
    end

    scheme = ENV["SCHEME"]
    UI.user_error!("Default Scheme not defined") if scheme.nil? || scheme.empty?

    return scheme
  end

end
